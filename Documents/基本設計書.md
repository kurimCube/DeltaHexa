# DeltaHexa  
## Unity基本設計書  
バージョン：0.1  
作成日：2026-02-12  

---

# 1. 目的

本書は「DeltaHexa」をUnityで実装するための基本設計を定義するものである。  
MVP（最小実装）を確実に完成させるためのシーン構成およびスクリプト構成を明確化する。

---

# 2. 設計方針

## 2.1 基本方針

- MVPを確実に完成させる
- ロジックとUIを分離する
- データと実行インスタンスを分離する
- 依存方向を明確にする

## 2.2 依存関係ルール

依存関係は以下の方向のみ許可する：

```
UI → Manager → Data / Logic
```

禁止事項：

- UIが直接ゲーム状態を書き換える
- Viewから他Managerへ直接アクセスする
- データ層がUIを参照する

---

# 3. シーン構成

## 3.1 シーン一覧

```
Scenes/
├── BootScene（将来）
├── TitleScene（将来）
└── BattleScene（MVP対象）
```


MVPではBattleSceneのみ実装対象とする。

---

## 3.2 BattleScene階層構造

```
BattleScene
├── GameRoot
│ ├── GameManager
│ ├── BattleManager
│ ├── BoardManager
│ ├── CardManager
│ ├── EnemyManager
│ └── EffectResolver
│
├── BoardRoot
│ └── (生成されるCellView)
│
├── UIRoot
│ ├── Canvas
│ │ ├── PlayerHPPanel
│ │ ├── EnemyHPPanel
│ │ ├── HandPanel
│ │ └── EndTurnButton
│
└── EventSystem
```


### 構成意図

- GameRoot：ロジック専用
- BoardRoot：盤面表示専用
- UIRoot：UI専用

---

# 4. ディレクトリ構成



```
Assets/
├── Scenes/
├── Scripts/
│ ├── Core/
│ ├── Board/
│ ├── Cards/
│ ├── Enemy/
│ ├── Effects/
│ ├── UI/
│ └── Utils/
└── Data/
├── Cards/
├── Enemies/
└── Relics/
```


---

# 5. スクリプト構成

## 5.1 Core

### GameManager.cs
- ゲーム全体管理
- シーン遷移（将来拡張）

### BattleManager.cs
- ターン管理
- 勝敗判定
- 状態遷移管理

### GameState.cs
- ゲーム状態enum定義

---

## 5.2 Board

### BoardManager.cs
- 盤面データ保持
- セル取得
- 配置可否判定
- 発動トリガー呼び出し

### Cell.cs
- セルデータ構造
  - 座標
  - 占有状態
  - 配置カード参照

### BoardGenerator.cs
- 24セル生成処理

### LineDetector.cs
- 直線完成判定ロジック
- 判定専用クラスとして分離

---

## 5.3 Cards

### CardData.cs
- ScriptableObject
- カード定義データ
  - 名前
  - 形状
  - 属性
  - 基礎威力

### CardInstance.cs
- 戦闘中のカード状態

### CardManager.cs
- デッキ管理
- 手札管理
- ドロー処理
- カード使用処理

### Deck.cs
- シャッフル
- カード追加削除

---

## 5.4 Enemy

### EnemyData.cs
- ScriptableObject
- 敵の基礎データ

### EnemyInstance.cs
- 戦闘中の敵状態

### EnemyManager.cs
- 敵行動処理
- ダメージ受理

---

## 5.5 Effects

### EffectResolver.cs
- 発動イベント処理
- 消去処理
- 効果解決順制御

### DamageCalculator.cs
- ダメージ計算処理分離

---

## 5.6 UI

### HandView.cs
- 手札表示制御

### CardView.cs
- カードUI表示
- クリック処理（Managerへ通知）

### CellView.cs
- セル描画
- 選択通知

### HPBarView.cs
- HP表示更新

### UIController.cs
- UI全体制御

---

## 5.7 Utils

### Constants.cs
- 共通定数

### Extensions.cs
- 拡張メソッド

---

# 6. MVP実装範囲

## 必須機能

- 24セル盤面生成
- カード配置
- 直線完成判定
- ダメージ処理
- 敵ターン処理
- 勝敗判定

## 非対象（後回し）

- レリック
- 状態異常詳細
- 演出強化
- アニメーション最適化

---

# 7. ターン制御設計

BattleManagerが状態を管理する。



```
enum BattleState
{
PlayerTurn,
Resolving,
EnemyTurn,
Win,
Lose
}
```


---

# 8. データ分離方針

- カード・敵データはScriptableObjectで管理
- 戦闘中状態はInstanceクラスで保持
- Viewは状態を保持しない

---

# 9. 拡張前提設計

将来的な拡張に備え：

- 発動判定はLineDetectorへ分離
- ダメージ計算はDamageCalculatorへ分離
- Manager間の直接依存を最小化

---

# 10. 実装優先順位

1. Board生成
2. 単マスカード配置
3. ライン完成検出
4. 敵HP減少
5. ターン遷移

---

# 11. 本設計の目的

- MVP完成を最優先とする
- 構造的に破綻しない設計を確保する
- ローグライト拡張に耐えうる基盤を作る

---

# 12. クラス間関係（概要）

## 12.1 主要クラス依存図（概念）

```
GameManager
↓
BattleManager
├── BoardManager
│ └── LineDetector
├── CardManager
│ └── Deck
├── EnemyManager
└── EffectResolver
└── DamageCalculator
```


UI層：

```
UIController
├── HandView
│ └── CardView
├── CellView
└── HPBarView
```


### 依存原則

- UIはManagerへ通知のみ行う
- ManagerはUIを直接参照しない
- 状態変更はBattleManagerが最終責任を持つ

---

# 13. データフロー設計

## 13.1 プレイヤーターンの流れ

1. CardViewがクリックされる
2. CardManagerへ使用通知
3. CellViewが選択される
4. BoardManagerが配置可否判定
5. 配置成功
6. LineDetectorが発動判定
7. EffectResolverが効果解決
8. EnemyManagerへダメージ通知
9. BattleManagerが状態遷移

---

## 13.2 敵ターンの流れ

1. BattleManagerがEnemyTurnへ遷移
2. EnemyManagerが行動決定
3. EffectResolverへ処理依頼
4. プレイヤーHP更新
5. BattleManagerがPlayerTurnへ戻す

---

# 14. イベント設計方針（MVP段階）

MVPでは過度なイベントバスは導入しない。

基本は：

- Manager間は直接参照可
- View → Managerはイベント通知

将来的に拡張する場合：

- C# event
- UnityEvent
- 独自EventBus

のいずれかへ移行可能な構造とする。

---

# 15. 盤面設計詳細

## 15.1 セルデータ構造

```
Cell
├── Vector2Int coordinate
├── bool isOccupied
├── CardInstance placedCard
└── bool isBlocked
```


## 15.2 盤面管理方式

BoardManagerは以下を保持する：

```
Dictionary<Vector2Int, Cell> cells;
List<List<Vector2Int>> precomputedLines;
```


- precomputedLinesは3方向の直線集合を事前計算して保持
- 判定高速化を目的とする

---

# 16. ダメージ処理設計

## 16.1 基本式（MVP）

```
最終ダメージ = 基礎威力合計
```


将来拡張：

```
(基礎威力合計 + 属性補正) × レリック倍率
```


DamageCalculatorが一括管理する。

---

# 17. 勝敗判定

BattleManagerが毎ターン終了時に判定。

## 勝利

```
if (enemy.hp <= 0)
state = Win;
```


## 敗北

```
if (player.hp <= 0)
state = Lose;
```


将来的に：

- 盤面完全埋まり判定
- 詰み判定

を追加可能。

---

# 18. UI更新設計

UIは状態変更通知を受けて更新する。

例：

- EnemyHP変更 → HPBarView.Update()
- 手札変更 → HandView.Refresh()

UIはロジックを持たない。

---

# 19. テスト戦略

## 19.1 ロジック単体テスト対象

- LineDetector
- DamageCalculator
- Deckシャッフル

## 19.2 手動テストフロー

1. 単マスカード配置
2. ライン完成確認
3. ダメージ確認
4. 敵ターン確認
5. 勝利判定確認

---

# 20. 将来拡張予定

- レリックシステム
- 属性連結ボーナス
- 状態異常
- 複数敵
- 演出アニメーション
- セーブデータ管理
- サウンド管理

---

# 21. 実装優先順位（開発ロードマップ）

## Phase 1（基盤）

- Board生成
- CellView表示
- 単マス配置

## Phase 2（戦闘成立）

- ライン判定
- ダメージ処理
- 敵ターン
- 勝敗判定

## Phase 3（カード要素）

- 複数形状カード
- デッキシャッフル
- 手札制御

## Phase 4（拡張）

- レリック
- 属性シナジー
- UI改善

---

# 22. 本設計の完成条件

以下が満たされた時、MVP完成とする：

- 1戦闘が最初から最後まで通せる
- ライン完成で攻撃が発生する
- 敵を倒せる
- 勝利画面が表示される

---

# 23. 本設計のゴール

- 構造的破綻を起こさない
- 拡張可能である
- 作り切れるサイズである
- ローグライト化に耐えうる基盤を持つ
